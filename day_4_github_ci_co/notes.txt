GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline.

A workflow is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.

Workflows are defined in the .github/workflows directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:

Building and testing pull requests
Deploying your application every time a release is created
Adding a label whenever a new issue is opened

An event is a specific activity in a repository that triggers a workflow run. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. 


A job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that will be executed, or an action that will be run. Steps are executed in order and are dependent on each other.

An action is a pre-defined, reusable set of jobs or code that performs specific tasks within a workflow, reducing the amount of repetitive code you write in your workflow files. Actions can perform tasks such as:

Pulling your Git repository from GitHub
Setting up the correct toolchain for your build environment
Setting up authentication to your cloud provider

A runner is a server that runs your workflows when they're triggered. Each runner can run a single job at a time. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your workflows. Each workflow run executes in a fresh, newly-provisioned virtual machine.


The GitHub Actions Hierarchy (The Russian Nesting Doll)
Think of GitHub Actions like an automated factory.

    The Event (The Trigger): The factory alarm goes off. ("Hey, Jay just pushed new code to the main branch!")

    The Workflow (The Factory Manager): The manager wakes up, looks at the .yml file you wrote, and says, "Okay, I see the instructions. I need to run the testing phase, and if that passes, the deployment phase."

    The Runner (The Workbench): GitHub spins up a blank, temporary Ubuntu Linux server just for you. This is where the actual work will happen.

    The Job (The Phase): A major grouping of work. For example, "Test the Code" is one Job. "Deploy the Docker Container" is a second Job. Each Job gets its own Runner (Workbench).

    The Step (The To-Do List): Inside a Job, you have a chronological list of things to do. "Step 1: Download Python. Step 2: Install dependencies. Step 3: Run Pytest."

    The Action (The Power Tool): Instead of writing 50 lines of bash script to download your code into the Runner, you use a pre-built "Action" that someone else wrote. It's a plug-and-play shortcut.

The Golden Rule of the Hierarchy:Events trigger Workflows $\rightarrow$ which contain Jobs $\rightarrow$ which execute on Runners $\rightarrow$ and are made of Steps $\rightarrow$ which use pre-built Actions or custom shell scripts.


That means, a typical github actins template file would look like this 

Name: workflow name 

on: 
  ... which events should trigger it 
  push:
    [branches]
  pull_request:

jobs:
  job_name
    runs-on: ubuntu-latest

    steps: ..... the steps in the job, remb each job runs in its own runner 
      name: install dependencies
      run: pip install -r requirements.txt
      uses: actions/checkout@v4 ... downloads and uses a predefined action 


name: CI Pipeline

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test-and-build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        run: |
          sudo apt update
          sudo apt install -y python3 python3-pip

      - name: Install dependencies
        run: pip3 install -r requirements.txt

      - name: Run tests
        run: pytest

      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .


Understanding ${{ }} Expressions
GitHub uses expression syntax:

${{ github.sha }}

This accesses context variables.

Common contexts:

    github.sha
    github.ref
    github.event_name
    secrets.MY_SECRET
      Defined in:
      Repo → Settings → Secrets
    env.VAR_NAME

Job Dependencies

Jobs can depend on each other.

Example:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Testing"

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - run: echo "Building"

Matrix lets you define a template once and generate multiple jobs automatically.

Basic Matrix Example
jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]

    steps:
      - name: Print version
        run: echo "Testing on ${{ matrix.python-version }}"

What Actually Happens Internally

GitHub does this behind the scenes:
It expands this into:

  Job 1:
  python-version = 3.9

  Job 2:
  python-version = 3.10

  Job 3:
  python-version = 3.11

Inside the job, GitHub injects a variable called matrix.

Important: Matrix is Job-Level, Not Step-Level
The entire job is duplicated.
Not just the step.
Everything inside the job runs multiple times.

Multi-Dimensional Matrix

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        python-version: [3.9, 3.10]

    runs-on: ${{ matrix.os }}

    steps:
      - name: Show combination
        run: echo "OS: ${{ matrix.os }}, Python: ${{ matrix.python-version }}"

GitHub generates all combinations.

This is called Cartesian product.

You get:

ubuntu + 3.9
ubuntu + 3.10
windows + 3.9
windows + 3.10

So 2 × 2 = 4 jobs.

Each combination runs separately.

if one job in the matrix fails, every other one fails, unless you specify otherwise
strategy:
  fail-fast: false
  matrix:
    python-version: [3.9, 3.10, 3.11]

Advanced: Excluding Combinations

Sometimes you don’t want every combination.

Example:

strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    python-version: [3.9, 3.10]
    exclude:
      - os: windows-latest
        python-version: 3.9

Now Windows + 3.9 won’t run.

You control exact combinations.

Artifacts are used to store and pass files across different jobs in github workflow. cod ordinarily ever job clears all its state before entering the next job. but with artifcats we can pass a file eg report or build wheels from one job to another

ARTIFACTS IN ACTION 

name: Python Data Pipeline CI

on:
  push:
    branches: [ "main" ]

jobs:
  # ==========================================
  # JOB 1: THE BUILDER (Runs once)
  # ==========================================
  build_package:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Compile heavy dependencies into a Wheel
        run: |
          pip install wheel
          # This command compiles the code and saves it in a folder called 'dist/'
          pip wheel . --wheel-dir=dist/ 

      - name: Upload the Wheel Artifact
        uses: actions/upload-artifact@v4
        with:
          name: compiled-wheel-files  # We name the USB drive
          path: dist/                 # We upload the whole 'dist' folder


  # ==========================================
  # JOB 2: THE MATRIX (Runs 3 times in parallel)
  # ==========================================
  test_matrix:
    # THE MAGIC: This forces the matrix to wait for Job 1 to finish successfully!
    needs: build_package 
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.10', '3.11']

    steps:
      - name: Checkout Code (Need the test files)
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      # THE RETRIEVAL: We plug the virtual USB drive into this new server
      - name: Download the Wheel Artifact
        uses: actions/download-artifact@v4
        with:
          name: compiled-wheel-files  # Must match the exact name from Job 1
          path: downloaded-wheels/    # Where to save it on this new server

      - name: Install the pre-compiled Artifact and Run Tests
        run: |
          # Install the .whl file we downloaded instead of building from scratch
          pip install downloaded-wheels/*.whl
          
          # Run the actual tests
          pytest tests/