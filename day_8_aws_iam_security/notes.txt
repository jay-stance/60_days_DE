Policies and permissions in AWS Identity and Access Management

Manage access in AWS by creating policies and attaching them to IAM identities (users, groups of users, or roles) or AWS resources. A policy is an object in AWS that, when associated with an identity or resource, defines their permissions. 

AWS supports seven types of policies: 
  - identity-based policies, 
  - resource-based policies, 
  - permissions boundaries, 
  - AWS Organizations service control policies (SCPs), 
  - AWS Organizations resource control policies (RCPs), 
  - access control lists (ACLs), 
  - and session policies.

  The AWS Hierarchy: The "Corporate Campus" Analogy
1. The AWS Organization (The Corporate Campus)
When a company signs up for AWS, they create an Organization. This is the top-level umbrella that holds the credit card used to pay the massive monthly cloud bill.

2. The AWS Account (The Office Buildings)
Instead of putting all their servers and data in one giant bucket, companies spin up multiple AWS Accounts. Think of an Account as a completely isolated office building with its own walls and locks.

The standard DE setup: A company will have a "Development Account" (where you test code) and a completely separate "Production Account" (where the live customer data lives).

Why? Because if a junior engineer accidentally writes a script that deletes everything in the "Development Account," the "Production Account" is physically separated. The blast radius is contained.

3. The IAM User (The Employee)
This is the person. An IAM User is Jay Stance logging in with a username and password. You, the human, are given an IAM User identity, and you are granted access to walk into specific AWS Accounts (office buildings).

4. The IAM Role (The Hard Hat)
This is the most important concept for a Data Engineer. A Role is an identity with permissions, but it does not have a password, and it does not belong to a specific person. It is a "hat" you can temporarily put on.

How DEs use it: You don't give your Python script your personal username and password. Instead, you create a "DataPipelineRole" (a hard hat). You tell AWS, "When my Python script runs on the server, let it wear this hard hat." The script assumes the role, gets temporary permission to read the database, and takes the hat off when it finishes.

5. The Resource (The Desks and Cabinets)
This is the actual stuff inside the AWS Account (the office building). It is the S3 buckets (filing cabinets), the EC2 instances (computers), and the RDS databases (vaults).


### AWS IAM Policies: The Cheat Sheet

**Category 1: The Daily Drivers (These GRANT access)**
These are the two policies you will write and attach constantly to make your pipelines work.

* **1. Identity-based Policies (The ID Badge)**
* **Attached to:** An IAM User (Person), Group (Team), or Role (Machine/Script).
* **Function:** Answers *"What can this entity do?"*
* **Example:** You attach a policy to your Python script's Role that says, *"You are allowed to read from the 'sales-data' database."*


* **2. Resource-based Policies (The Smart Lock)**
* **Attached to:** An AWS Resource itself (like an Amazon S3 Bucket or an SQS Queue).
* **Function:** Answers *"Who is allowed to touch this specific thing?"*
* **Example:** You attach a policy to a specific S3 bucket that says, *"Only the Finance Team's AWS Account is allowed to drop files in here."*



**Category 2: The Guardrails (These LIMIT access, they never grant it)**
These act as "ceilings" to prevent catastrophic security breaches. Even if an Identity policy grants access, these guardrails can block it.

* **3. Permissions Boundaries (The HR Job Description)**
* **Attached to:** An IAM User or Role.
* **Function:** Defines the absolute maximum permissions an entity can have. Used to prevent a developer from accidentally giving a script "Admin" access.


* **4. Service Control Policies / SCPs (The CEO's User Mandate)**
* **Attached to:** An entire AWS Account or Organization.
* **Function:** Sets a universal limit on what *Users and Roles* can do across the whole account.
* **Example:** *"Nobody in the Dev Account is allowed to delete a database, period."*


* **5. Resource Control Policies / RCPs (The Landlord's Building Code)**
* **Attached to:** An entire AWS Account or Organization.
* **Function:** Sets a universal limit on the *Resources* themselves.
* **Example:** *"No S3 bucket in this account can ever be made public to the internet, even if someone writes a Resource-based policy trying to allow it."*



**Category 3: The Niche & Legacy (Rarely Used)**
You will only see these in very specific edge cases or legacy systems.

* **6. Access Control Lists / ACLs (The VIP Guest List)**
* **Function:** A legacy way to grant access to resources from *other* AWS accounts. Modern AWS architecture strongly prefers you use Resource-based policies instead.


* **7. Session Policies (The Temporary Visitor Pass)**
* **Function:** A policy you pass dynamically at the exact moment a script "assumes" a Role. It temporarily restricts what that Role can do for the duration of that specific login session.


========================================

      DETAILED - POLICIES 

========================================


AWS IAM: Resource-Based Policies & Cross-Account Access
1. The Basics (Inline Policies)

    What they are: JSON documents bolted directly onto an AWS Resource (like an S3 bucket or SQS queue).

    Managed vs. Inline: There is no central library for these. They are always Inline (custom-written directly onto the specific resource).

    The Principal: The policy must explicitly define the Principal (the "Who"â€”a User, a Role, or another Account) that is allowed to access the resource.

2. The "Two-Way Handshake" (Cross-Account Access)
How permissions work depends on where the data is and who is asking for it:

  Same Account (One-Way Trust): If your Python script and the S3 bucket are in the exact same AWS Account, you only need one policy to grant access. If the S3 bucket has a Resource-based policy saying "The script can read me," access is granted.

  Cross-Account (Two-Way Trust): If your script (Account A) wants to read a vendor's S3 bucket (Account B), both sides must explicitly agree:

    The Vendor (Account B) attaches a Resource-based policy to their bucket: "Account A is allowed in."

    You (Account A) must attach an Identity-based policy to your script: "You have permission to leave our account and access Account B."

3. IAM Roles: The "Dual-Nature" Exception
    An IAM Role is unique because it acts as both an Identity (it accesses things) AND a Resource (it sits in your account waiting to be used). Because of this, creating a Role always requires two policies:

    Policy 1: The Trust Policy (Resource-based): Defines Who is allowed to put on this Role? (e.g., "Only this specific EC2 virtual server can assume this role.")

    Policy 2: The Permissions Policy (Identity-based): Defines What can they do once wearing it? (e.g., "Once assumed, you can read the Postgres database.")


1. Permissions Boundaries (The Individual Guardrail)

    What it is: A strict maximum limit placed on a specific IAM User or Role.

    How it works (The Venn Diagram): You are only granted permissions that are allowed by BOTH your Identity policy AND your Boundary.

    The Exception: If a Resource-based policy (like an S3 bucket) names your specific, temporary active Session, it can bypass the boundary's need to explicitly allow it.

2. Service Control Policies / SCPs (The Account-Wide Guardrail)

    What it is: A maximum limit placed on an entire AWS Account from the Organization level.

    The Power: It restricts everyone in that account, including the god-mode Root User.

3. The Golden Rule of Evaluation

    Explicit Deny Always Wins: If any policy in the entire chain (SCP, Boundary, Identity, or Resource) contains an explicit Deny, it completely overrides any Allow from any other policy.


The Summary for your Notes
1. Resource Control Policies / RCPs (The Ultimate Resource Guardrail)

  - What it is: A maximum limit placed on the Resources (S3 buckets, etc.) across an entire AWS Account from the Organization level.

  - The Power: It overrides Resource-based policies. If a bucket's policy tries to allow the public internet in, an RCP can block it at the account border. It applies to everyone, even external users and the Root User.

  - SCP vs RCP: SCPs put a ceiling on your Users. RCPs put a ceiling on your Resources.

2. Access Control Lists / ACLs (The Legacy Cross-Account Tool)

  - What it is: The old, non-JSON way of granting access to a resource.

  - The Limitation: It can only be used to grant access to external AWS accounts. It cannot grant access to users within the same account.

  - Modern Usage: Rarely used. Modern AWS architecture relies entirely on JSON Resource-based policies instead.

Session Policies (The Temporary Filter)

  What it is: A JSON policy passed dynamically inside your code when you request temporary AWS credentials (via AWS STS / AssumeRole).

  The Function: It never grants access. It only filters or limits the permissions your Role normally has for the duration of that specific temporary session.

  The Use Case: The Principle of Least Privilege. If a powerful Role is assumed for a minor task, you pass a Session Policy to handicap the Role temporarily, ensuring that if the script crashes or is compromised, the blast radius is tiny.

  Federation: This is the exact mechanism used behind the scenes when you log into AWS using an external identity provider like Okta or Google.


The AWS Root User (God-Mode)

  What it is: The original email address used to create the AWS account. It inherently has full admin access to everything inside that account.

  What DOES NOT affect it: You cannot attach Identity-based policies to it (it doesn't need them), and you cannot restrict it with Permissions Boundaries.

  How it interacts with Resources: You can name a Root User as the Principal in a Resource-based policy (usually to grant cross-account access to an entire foreign account).

  The Only Way to Restrict It: If the Account is part of a larger AWS Organization, the overarching SCPs and RCPs apply to the Account itself, meaning they will successfully block even the Root User.


JSON Policies & Evaluation

    The DE Standard: Always write your policies in JSON. Avoid relying on the AWS Visual Console, as console clicks cannot be automated in CI/CD pipelines.

    Logical OR (Additive Stacking): If you have multiple Allow statements across different policies, AWS stacks them together. You get the combined total of all permissions.

    Access Analyzer: Always use this to validate your JSON. It catches syntax errors and prevents catastrophic security misconfigurations before you save the file.


The 6 Elements of a JSON IAM Policy

    Version: Always "2012-10-17".

    Statement: The container array holding your individual rules.

    Sid: An optional, human-readable name for the rule.

    Effect: "Allow" or "Deny".

    Action: The API verb (e.g., "s3:GetObject").

    Condition: Optional rules (e.g., IP address restrictions, MFA requirements).

The Golden Rule of Who and Where

    Identity Policies (ID Badges): Require a Resource (Where), but NEVER have a Principal (Who).

    Resource Policies (Smart Locks): Require a Principal (Who), but the Resource (Where) is usually implied.


Structuring IAM Policies (Best Practices)

    Keep it Modular: Do not put unrelated permissions (like S3 access and IAM user management) into the same JSON statement or file. Break them into separate, functionally grouped policies.

    Size Limits: AWS enforces strict character limits on JSON policies. Modular policies prevent you from hitting this ceiling.

    The * Boundary: Using "Resource": "*" applies to all resources within your specific AWS account, not the entire AWS ecosystem.

    The Power of Condition: A statement with a Condition (like enforcing MFA or IP address restrictions) only activates if the condition is 100% true. If false, the permission is entirely ignored.


{
  "Version":"2012-10-17",		 	 	 
  "Statement": [
    {
      "Sid": "FirstStatement",
      "Effect": "Allow",
      "Action": ["iam:ChangePassword"],
      "Resource": "*"
    },
    {
      "Sid": "SecondStatement",
      "Effect": "Allow",
      "Action": "s3:ListAllMyBuckets",
      "Resource": "*"
    },
    {
      "Sid": "ThirdStatement",
      "Effect": "Allow",
      "Action": [
        "s3:List*",
        "s3:Get*"
      ],
      "Resource": [
        "arn:aws:s3:::amzn-s3-demo-bucket-confidential-data",
        "arn:aws:s3:::amzn-s3-demo-bucket-confidential-data/*"
      ],
      "Condition": {"Bool": {"aws:MultiFactorAuthPresent": "true"}}
    }
  ]
}


{
    "Version":"2012-10-17",		 	 	 
    "Statement": [
        {
            "Sid": "1",
            "Effect": "Allow",
            "Principal": {
                "AWS": [
                    "arn:aws:iam::111122223333:root"
                ]
            },
            "Action": "s3:*",
            "Resource": [
                "arn:aws:s3:::amzn-s3-demo-bucket",
                "arn:aws:s3:::amzn-s3-demo-bucket/*"
            ]
        }
    ]
}


The Principle of Least Privilege (PoLP)

    The Golden Rule: Never use wildcards (*) just to make things work faster. Only grant the exact permissions required for the specific task. Start strict, add permissions only when proven necessary.

    Access Advisor: The "Last Accessed" tool. Use it to audit your team. If a permission hasn't been used in 90 days, revoke it.

    CloudTrail: The universal AWS logbook. It records every API call made in your account.

    Access Analyzer Policy Generation: The automated JSON writer. It scans CloudTrail logs to see what your script actually did, and generates a perfectly scoped Least Privilege policy based on real activity.


Roles: Temporary, assumable identities. The absolute standard for giving applications, scripts, and federated human users access to AWS.

Service-Linked Roles: Auto-generated roles owned by AWS. Do not touch them.

Role Chaining: Assuming a role while wearing a role. Hard-capped at a 1-hour session limit.

Trust Policies: The specific JSON policy attached to a Role that dictates exactly who or what is allowed to assume it.

Federation: Using SSO (like Google or Okta) to authenticate. AWS trusts the SSO and hands you a temporary Role instead of making you maintain an IAM User password.